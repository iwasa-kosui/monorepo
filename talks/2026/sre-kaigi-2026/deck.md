---
presentationID: 1wu9iH8VOLA3JHpRSR4B4wdlSjdFnww-S3Ru7keN9MWk
---

# 開発チームが信頼性向上のためにできること

## 医療SaaS企業を支える共通基盤の挑戦

kosui (岩佐 幸翠) / 株式会社カケハシ

---

# 自己紹介

## 導入: kosui (岩佐 幸翠)

- 株式会社カケハシ
- 共通基盤チーム
- 認証基盤・データ基盤の設計・開発

---

# 本日のキーメッセージ

## 導入: 開発チームが設計を"自分ごと"として運用し続けることで、信頼性は向上できる

- SRE専任チームがなくても、開発チームが主体的に取り組める
- 設計パターンを「選ぶ」だけでなく「育てる」ことが重要
- 本セッションでは、その具体的な方法論を共有します

---

# 本日お話しすること

## 導入: アジェンダ

1. 背景: なぜ開発チームが信頼性を担う必要があったか
2. 課題: 開発効率と信頼性の両立
3. 方法論: ドメインイベント、データ連携、RLS
4. 結果と教訓: 「責任を果たす」とは何か
5. まとめ

---

# 背景

## 背景: なぜ開発チームが信頼性を担う必要があったか

- チーム規模とSREの関係
- 医療SaaSという特殊なドメイン
- 「自分たちで責任を持つ」という選択

---

# チーム規模の制約

## 背景: 私たちの状況

- チーム全体の規模に対してSRE専任を置いても十分な協働が難しい
- バックエンド〜フロントエンドを担う開発チーム自身が信頼性向上に主体的に取り組む必要があった

---

# 制約があったからこそ

## 背景: 開発チーム自身が責任を持つ道を選んだ

- 「誰かの仕事」ではなく「自分たちの責任」
- 制約をネガティブに捉えず、チームの強みに変える
- 設計・実装・運用を一貫して担うことで、深い理解と迅速な改善が可能に

---

# 医療SaaSの特殊性

## 背景: カケハシのコンテキスト

- 薬局向けSaaSを4つ以上開発・運用
- すべてが医療情報システムとして患者情報を扱う

---

# 医療分野特有の制約

## 背景: セキュリティ・可用性・整合性

- **セキュリティ**: 3省2ガイドライン（MFA必須、監査ログ長期保存）
- **可用性**: 医療機関は24時間365日稼働
- **データ整合性**: 患者情報・処方データは不整合が許されない

---

# 課題

## 課題: 開発効率と信頼性の両立

- なぜ両立が難しいのか
- 具体的にどんな問題が発生していたか
- 解決すべき2つの課題

---

# トレーサビリティの欠如

## 課題: 既存システムの問題

- 最新データしか保存されていない
- 障害発生時の原因調査に時間がかかる
- 「3ヶ月前のこの患者のデータがどうだったか」を説明できない

---

# 開発効率と信頼性のトレードオフ

## 課題: 両立が難しい

- 信頼性を上げようとすると開発速度が落ちる
- 開発速度を優先すると信頼性が犠牲になる
- どちらも諦められない

---

# 方法論

## 方法論: 開発チームが実践できる具体的手法

- 特別なツールや大規模な組織変更は不要
- 既存の技術を組み合わせて信頼性を向上
- 段階的に導入可能なアプローチ

---

# 方法論の全体像

## 方法論: 4つのアプローチ

1. **ドメインイベントの永続化**: 完全なトレーサビリティ
2. **データ連携パターンの選択**: 即時性 vs 耐障害性
3. **サービスベースアーキテクチャ**: 強い整合性
4. **RLSによるマルチテナント分離**: セキュリティ

---

# 設計を選ぶだけでなく

## 方法論: その意図を理解し運用し続けることが重要

- なぜその設計を選んだのかを言語化する
- トレードオフを明示的にチームで共有する
- 定期的に設計判断を振り返り、改善する

---

# ドメインイベント

## 方法論: 完全なトレーサビリティの実現

- 「何が起きたか」を全て記録する設計パターン
- 障害調査、監査対応、データ復旧に活用
- イベントソーシングの考え方を部分的に導入

---

# ドメインイベントとは

## 方法論 - ドメインイベント: 全ての変更を記録する

- いつ、誰が、何を変更したかを完全に記録
- 過去のあらゆる時点の状態を再現可能にする
- イベントのリプレイによる状態の再構築

---

# ドメインイベントの設計

## 方法論 - ドメインイベント: 型定義

```typescript
type DomainEvent<TAggregateKind, TAggregateId, TAggregate, TEventName, TEventPayload> = {
  aggregateKind: TAggregateKind;
  aggregateId: TAggregateId;
  aggregate: TAggregate;  // 変更後の状態
  eventId: EventId;
  eventName: TEventName;
  eventPayload: TEventPayload;
  eventAt: UnixTime;
};
```

---

# イベントストアの実装

## 方法論 - ドメインイベント: ストレージ戦略

```sql
CREATE TABLE events (
  event_id UUID PRIMARY KEY,
  aggregate_kind TEXT NOT NULL,
  aggregate_id UUID NOT NULL,
  event_name TEXT NOT NULL,
  event_payload JSONB NOT NULL,
  aggregate_snapshot JSONB NOT NULL,
  event_at TIMESTAMPTZ NOT NULL
) PARTITION BY RANGE (event_at);
```

---

# イベント発行の実装例

## 方法論 - ドメインイベント: アプリケーションコード

```typescript
// ユーザー作成時にイベントを発行
const createUser = (props: CreateUserProps): UserCreated => {
  const userId = UserId.generate();
  const user: User = { userId, ...props, status: 'active' };

  return {
    aggregateKind: 'User',
    aggregateId: userId,
    aggregate: user,
    eventId: EventId.generate(),
    eventName: 'UserCreated',
    eventPayload: { createdBy: props.createdBy },
    eventAt: UnixTime.now(),
  };
};
```

---

# ドメインイベント導入の工数感

## 方法論 - ドメインイベント: 導入コスト

- 既存コードへの影響を最小限に抑えるアプローチ
- 段階的に導入可能
- クリティカルな領域から優先的に適用

---

# データ連携パターン

## 方法論: 即時性 vs 耐障害性の選択

- システム間でデータをどう共有するか
- 基盤障害が全プロダクトに波及しない設計
- ユースケースに応じた使い分けが重要

---

# データ連携パターン比較

## 方法論 - データ連携: 3つの選択肢

| パターン | 即時性 | 耐障害性 | 一貫性 |
|----------|--------|----------|--------|
| API連携 | ◎ | △ | ◎ |
| イベント連携 | ○ | ○ | ○ |
| データ基盤経由 | △ | ◎ | ◎ |

---

# 選択基準

## 方法論 - データ連携: ユースケースに応じた使い分け

- **即時性が必要** → API連携 or イベント連携
- **耐障害性・一貫性重視** → データ基盤経由
- **基盤障害を波及させない** → データ基盤経由をデフォルトに

---

# Delta Lake + タイムトラベル

## 方法論 - データ連携: データ基盤の実装

- Parquet形式でS3に保存（99.999999999%の耐久性）
- ACIDトランザクションをサポート
- タイムトラベル機能で過去の状態にアクセス可能

---

# タイムトラベルの活用

## 方法論 - データ連携: 過去の状態へのアクセス

```python
# 現在のデータを取得
df = spark.read.format("delta").load("s3://bucket/users")

# 3ヶ月前の状態を取得
df_past = spark.read.format("delta") \
    .option("timestampAsOf", "2025-10-01") \
    .load("s3://bucket/users")
```

---

# サービスベースアーキテクチャ

## 方法論: 強い整合性が必要な場合

- マイクロサービスでもモノリスでもない選択肢
- 単一DBを共有しつつ、サービスを論理的に分離
- トランザクションによる整合性保証

---

# なぜマイクロサービスではないのか

## 方法論 - アーキテクチャ: 選択肢の比較

1. モノリス → スケーラビリティの問題
2. マイクロサービス → 分散トランザクション、整合性の問題
3. **サービスベースアーキテクチャ** → 適度な分離と整合性のバランス

---

# サービスベースアーキテクチャ

## 方法論 - アーキテクチャ: 選んだ理由

- 単一のPostgreSQLを共有
- トランザクションで整合性を保証
- サービス間通信を原則禁止

---

# サービス間の結合度管理

## 方法論 - アーキテクチャ: 実装ルール

- 各サービスは自分のテーブルにのみ書き込み権限
- 他のテーブルは読み取り専用ユーザーで参照
- 外部キー制約でデータ整合性を保証

---

# DBユーザー分離の実装

## 方法論 - アーキテクチャ: コード例

```sql
-- サービスAのユーザー（自分のテーブルのみ書き込み可能）
CREATE USER service_a_user WITH PASSWORD '...';
GRANT SELECT, INSERT, UPDATE, DELETE ON service_a.* TO service_a_user;
GRANT SELECT ON service_b.* TO service_a_user;  -- 他は読み取りのみ

-- 外部キー制約で整合性を保証
ALTER TABLE service_a.orders
  ADD CONSTRAINT fk_user
  FOREIGN KEY (user_id) REFERENCES service_b.users(id);
```

---

# RLS

## 方法論: PostgreSQL行レベルセキュリティ

- マルチテナントSaaSにおけるデータ分離
- アプリケーションのバグがあっても漏洩しない
- DBレベルでの強制的な保護

---

# RLSの選択理由

## 方法論 - RLS: マルチテナント分離の課題

**課題**: 顧客Aのデータを顧客Bが絶対に参照できないようにする

1. アプリケーションレベルでのフィルタリング → 実装ミスのリスク
2. スキーマ分離 → 管理コストが膨大
3. **行レベルセキュリティ（RLS）** → DBレベルで強制保護

---

# RLSのメリット

## 方法論 - RLS: なぜRLSを選んだか

- SQLインジェクションやバグがあっても他テナントのデータは漏洩しない
- ポリシーはテーブル定義と一緒に管理できる
- 既存のクエリを変更する必要がない

---

# RLSの実装パターン

## 方法論 - RLS: コード例

```sql
-- テナントコンテキストの設定
SET app.current_tenant_id = 'tenant_123';

-- RLSポリシーの定義
CREATE POLICY tenant_isolation_policy ON users
  USING (tenant_id = current_setting('app.current_tenant_id')::uuid);

ALTER TABLE users ENABLE ROW LEVEL SECURITY;
```

---

# アプリケーション側の実装

## 方法論 - RLS: ミドルウェアでの設定

```typescript
// リクエストごとにテナントIDを設定
const tenantMiddleware = async (req, res, next) => {
  const tenantId = extractTenantId(req);

  // DB接続時にテナントコンテキストを設定
  await db.query(`SET app.current_tenant_id = $1`, [tenantId]);

  next();
};

// これ以降のクエリは自動的にテナントでフィルタリングされる
const users = await db.query('SELECT * FROM users');
```

---

# 結果と教訓

## 結果と教訓: 「責任を果たす」とは何か

- 導入して終わりではない
- 運用・監視・改善を継続することが本質
- 失敗から学んだことも共有

---

# 成果

## 結果と教訓: Before / After

| 項目 | Before | After |
|------|--------|-------|
| 障害発生時の原因特定時間 | 数時間〜 | 大幅に短縮 |
| 過去データの追跡 | 不可能 | 任意の時点で可能 |
| テナント分離の信頼性 | アプリ依存 | DB保証 |

---

# 失敗から学んだこと

## 結果と教訓: 教訓

- RLSのマイグレーションは慎重に（PERMISSIVEモードから開始）
- 共通ライブラリにビジネスロジックを入れすぎない
- 理想的には最初からイベントを記録すべき

---

# 「責任を果たす」とは

## 結果と教訓: 設計を選ぶだけでは終わらない

1. **設計の意図を理解する**
2. **運用し続ける**
3. **監視する**
4. **改善し続ける**

---

# 責任を果たすサイクル

## 結果と教訓: 継続的な改善

- **設計**: 原則に基づいて技術を選択
- **運用**: 本番環境で動かし続ける
- **監視**: メトリクス・ログ・アラートで状態を把握
- **改善**: 問題を発見したら修正し、設計にフィードバック

このサイクルを開発チームが自走できる状態を目指す

---

# まとめ

## まとめ: 持ち帰りポイント

- 開発チームでも信頼性向上は実現できる
- 重要なのは技術選定だけでなく、運用し続けること
- 今日紹介した4つの方法論は段階的に導入可能

---

# 開発チームができること

## まとめ: SRE専任がいなくても

1. **ドメインイベント**: トレーサビリティの確保
2. **データ連携パターン**: ユースケースに応じた選択
3. **サービスベースアーキテクチャ**: 強い整合性
4. **RLS**: DBレベルでのセキュリティ

---

# Enablingの観点から

## まとめ: 開発チームが自分事として信頼性を担う状態

- 設計を選ぶだけでなく、責任を果たす
- 運用・監視・改善を継続する
- 「誰かの仕事」ではなく「自分たちの責任」

---

# 本日のキーメッセージ（再掲）

## まとめ: アーキテクチャを選び、育て、責任を果たす

- 設計パターンは「導入して終わり」ではない
- チームで意図を共有し、継続的に改善する
- それが開発チームによる信頼性向上の本質

---

# ご清聴ありがとうございました

## Q&A

質問があればぜひ！
