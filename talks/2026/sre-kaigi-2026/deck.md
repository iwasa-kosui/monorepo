---
presentationID: 1g-QilHBVeoCd7lxMb0JNHUbHbFgkEJ3uj_5fnFy3p3w
---
# 開発チームが信頼性向上のためにできること

## 医療SaaS企業を支える共通基盤の挑戦

kosui (岩佐 幸翠) / 株式会社カケハシ

<!--
本日は「開発チームが信頼性向上のためにできること」というテーマでお話しします。
医療SaaS企業であるカケハシで、共通基盤チームがどのように信頼性向上に取り組んできたかを共有します。
-->

---

# 自己紹介

## 導入

- 株式会社カケハシ
- 共通基盤チーム
- 認証基盤・データ基盤の設計・開発

<!--
私はカケハシで共通基盤チームに所属しています。
認証基盤やデータ基盤など、複数プロダクトで共通して使われる基盤の設計・開発を担当しています。
-->

---

# 本日のキーメッセージ

## 導入

- 開発チームが設計を"自分ごと"として運用し続けることで、信頼性は向上できる
- SRE専任チームがなくても、開発チームが主体的に取り組める
- 設計パターンを「選ぶ」だけでなく「育てる」ことが重要

<!--
本日お伝えしたいキーメッセージはこちらです。
SRE専任チームがいない環境でも、開発チーム自身が設計を理解し、運用し続けることで信頼性は向上できます。
重要なのは、設計パターンを選んで終わりではなく、チームで育て続けることです。
-->

---

# 本日お話しすること

## 導入

1. 背景: なぜ開発チームが信頼性を担う必要があったか
2. 課題: 開発効率と信頼性の両立
3. 方法論: ドメインイベント、データ連携、RLS
4. 結果と教訓: 「責任を果たす」とは何か
5. まとめ

<!--
本日のアジェンダです。
まず背景として、なぜ開発チームが信頼性を担う必要があったのかをお話しします。
次に課題、そして具体的な方法論、最後に結果と教訓をお伝えします。
-->

---

# 背景

## 背景

- チーム規模とSREの関係
- 医療SaaSという特殊なドメイン
- 「自分たちで責任を持つ」という選択

<!--
まず背景についてお話しします。
なぜ私たちは開発チーム自身が信頼性を担う道を選んだのか、その理由を説明します。
-->

---

# チーム規模の制約

## 背景

- チーム全体の規模に対してSRE専任を置いても十分な協働が難しい
- バックエンド〜フロントエンドを担う開発チーム自身が信頼性向上に主体的に取り組む必要があった

<!--
私たちのチームでは、規模に対してSRE専任を置いても十分な協働が難しい状況でした。
そのため、開発チーム自身が信頼性向上に主体的に取り組む必要がありました。
これは制約でしたが、後に強みに変わっていきます。
-->

---

# 制約があったからこそ

## 背景

- 「誰かの仕事」ではなく「自分たちの責任」
- 制約をネガティブに捉えず、チームの強みに変える
- 設計・実装・運用を一貫して担うことで、深い理解と迅速な改善が可能に

<!--
この制約があったからこそ、信頼性を「誰かの仕事」ではなく「自分たちの責任」として捉えることができました。
設計・実装・運用を一貫して担うことで、システムへの深い理解が生まれ、問題発生時も迅速に改善できるようになりました。
-->

---

# 医療SaaSの特殊性

## 背景

- 薬局向けSaaSを4つ以上開発・運用
- すべてが医療情報システムとして患者情報を扱う

<!--
カケハシでは薬局向けSaaSを4つ以上開発・運用しています。
すべてのプロダクトが医療情報システムとして患者情報を扱うため、特別な配慮が必要です。
-->

---

# 医療分野特有の制約

## 背景

- **セキュリティ**: 3省2ガイドライン（MFA必須、監査ログ長期保存）
- **可用性**: 医療機関は24時間365日稼働
- **データ整合性**: 患者情報・処方データは不整合が許されない

<!--
医療分野には特有の制約があります。
3省2ガイドラインによりMFA必須や監査ログの長期保存が求められます。
また、医療機関は24時間365日稼働しており、高い可用性が必要です。
患者情報や処方データは不整合が許されず、データ整合性の担保が重要です。
-->

---

# 課題

## 課題

- なぜ両立が難しいのか
- 具体的にどんな問題が発生していたか
- 解決すべき2つの課題

<!--
次に、私たちが直面していた課題についてお話しします。
開発効率と信頼性の両立が難しい理由と、具体的な問題について説明します。
-->

---

# トレーサビリティの欠如

## 課題

- 最新データしか保存されていない
- 障害発生時の原因調査に時間がかかる
- 「3ヶ月前のこの患者のデータがどうだったか」を説明できない

<!--
最大の課題は、トレーサビリティの欠如でした。
従来のシステムでは最新データしか保存されていなかったため、障害発生時の原因調査に時間がかかりました。
また、過去のデータ状態を説明できないことは、医療という特殊なドメインでは大きな問題でした。
-->

---

# 開発効率と信頼性のトレードオフ

## 課題

- 信頼性を上げようとすると開発速度が落ちる
- 開発速度を優先すると信頼性が犠牲になる
- どちらも諦められない

<!--
信頼性と開発効率はトレードオフの関係にあると思われがちです。
しかし、医療SaaSでは両方とも諦めることができません。
このトレードオフをどう解決するかが、私たちのチャレンジでした。
-->

---

# 方法論

## 方法論

- 特別なツールや大規模な組織変更は不要
- 既存の技術を組み合わせて信頼性を向上
- 段階的に導入可能なアプローチ

<!--
ここからは、私たちが実践した具体的な方法論をお話しします。
特別なツールや大規模な組織変更は必要ありません。
既存の技術を組み合わせ、段階的に導入できるアプローチです。
-->

---

# 方法論の全体像

## 方法論

1. **ドメインイベントの永続化**: 完全なトレーサビリティ
2. **データ連携パターンの選択**: 即時性 vs 耐障害性
3. **サービスベースアーキテクチャ**: 強い整合性
4. **RLSによるマルチテナント分離**: セキュリティ

<!--
方法論は4つあります。
まずドメインイベントの永続化によるトレーサビリティの確保。
次にユースケースに応じたデータ連携パターンの選択。
そしてサービスベースアーキテクチャによる整合性の担保。
最後にRLSによるマルチテナントのセキュリティ確保です。
-->

---

# 設計を選ぶだけでなく

## 方法論

- なぜその設計を選んだのかを言語化する
- トレードオフを明示的にチームで共有する
- 定期的に設計判断を振り返り、改善する

<!--
重要なのは、設計パターンを選ぶだけでなく、その意図を理解し運用し続けることです。
なぜその設計を選んだのかを言語化し、トレードオフをチームで共有します。
定期的に振り返り、改善していくことが本質です。
-->

---

# ドメインイベント

## 方法論 - ドメインイベント

- 「何が起きたか」を全て記録する設計パターン
- 障害調査、監査対応、データ復旧に活用
- イベントソーシングの考え方を部分的に導入

<!--
まず、ドメインイベントについてお話しします。
これは「システムで何が起きたか」をすべて記録する設計パターンです。
障害調査、監査対応、データ復旧など様々な場面で活用できます。
-->

---

# ドメインイベントとは

## 方法論 - ドメインイベント

- いつ、誰が、何を変更したかを完全に記録
- 過去のあらゆる時点の状態を再現可能にする
- イベントのリプレイによる状態の再構築

<!--
ドメインイベントとは、いつ、誰が、何を変更したかを完全に記録する仕組みです。
これにより、過去のあらゆる時点の状態を再現できます。
イベントをリプレイすることで、任意の時点の状態を再構築できます。
-->

---

# ドメインイベントの設計指針

## 方法論 - ドメインイベント

- 集約（Aggregate）ごとにイベントを定義
- 変更後の状態（スナップショット）も一緒に保存
- イベント名で「何が起きたか」を明示

<!--
ドメインイベントを設計する際の指針を説明します。
まず、集約ごとにイベントを定義します。
イベントには変更後の状態も一緒に保存することで、リプレイなしでも状態を参照できます。
イベント名は「UserCreated」のように、何が起きたかを明示します。
-->

---

# ドメインイベントの型定義

## 方法論 - ドメインイベント

```typescript
type DomainEvent<TAggregateKind, TAggregateId, TAggregate, TEventName, TEventPayload> = {
  aggregateKind: TAggregateKind;
  aggregateId: TAggregateId;
  aggregate: TAggregate;  // 変更後の状態
  eventId: EventId;
  eventName: TEventName;
  eventPayload: TEventPayload;
  eventAt: UnixTime;
};
```

<!--
こちらが実際の型定義です。
集約の種類、ID、変更後の状態、イベントIDと名前、ペイロード、発生日時を持ちます。
aggregateフィールドに変更後の状態を持つことで、過去の状態を即座に参照できます。
-->

---

# イベントストアの設計指針

## 方法論 - ドメインイベント

- イベントは追記のみ、更新・削除は禁止
- パーティショニングでパフォーマンスを確保
- JSONBで柔軟にペイロードを保存

<!--
イベントストアの設計指針です。
イベントは追記のみで、更新や削除は禁止します。これにより監査ログとしても機能します。
日時でパーティショニングすることで、大量のイベントでもパフォーマンスを確保できます。
-->

---

# イベントストアの実装

## 方法論 - ドメインイベント

```sql
CREATE TABLE events (
  event_id UUID PRIMARY KEY,
  aggregate_kind TEXT NOT NULL,
  aggregate_id UUID NOT NULL,
  event_name TEXT NOT NULL,
  event_payload JSONB NOT NULL,
  aggregate_snapshot JSONB NOT NULL,
  event_at TIMESTAMPTZ NOT NULL
) PARTITION BY RANGE (event_at);
```

<!--
こちらがPostgreSQLでの実装例です。
イベントIDをプライマリキーとし、集約の種類とIDでフィルタリングできるようにします。
aggregate_snapshotに変更後の状態を保存し、event_atでパーティショニングしています。
-->

---

# イベント発行の設計指針

## 方法論 - ドメインイベント

- ドメイン層でイベントを生成
- 永続化はアプリケーション層で行う
- トランザクション内でイベントも保存

<!--
イベント発行の設計指針です。
イベントの生成はドメイン層で行い、純粋な関数として実装します。
永続化はアプリケーション層で行い、業務データとイベントを同一トランザクションで保存します。
-->

---

# イベント発行の実装例

## 方法論 - ドメインイベント

```typescript
// ユーザー作成時にイベントを発行
const createUser = (props: CreateUserProps): UserCreated => {
  const userId = UserId.generate();
  const user: User = { userId, ...props, status: 'active' };

  return {
    aggregateKind: 'User',
    aggregateId: userId,
    aggregate: user,
    eventId: EventId.generate(),
    eventName: 'UserCreated',
    eventPayload: { createdBy: props.createdBy },
    eventAt: UnixTime.now(),
  };
};
```

<!--
こちらがアプリケーションコードでの実装例です。
ユーザー作成関数は、ユーザーオブジェクトではなくイベントを返します。
イベントにはユーザーの状態と、誰が作成したかというペイロードが含まれます。
-->

---

# ドメインイベント導入の工数感

## 方法論 - ドメインイベント

- 既存コードへの影響を最小限に抑えるアプローチ
- 段階的に導入可能
- クリティカルな領域から優先的に適用

<!--
導入の工数についてです。
既存コードへの影響を最小限に抑えながら、段階的に導入できます。
すべてに一度に適用する必要はなく、監査が重要な領域や障害調査が困難な領域から優先的に適用していきます。
-->

---

# データ連携パターン

## 方法論 - データ連携

- システム間でデータをどう共有するか
- 基盤障害が全プロダクトに波及しない設計
- ユースケースに応じた使い分けが重要

<!--
次に、データ連携パターンについてお話しします。
複数のプロダクトでデータを共有する際、基盤障害が全体に波及しない設計が重要です。
ユースケースに応じて適切なパターンを選択します。
-->

---

# データ連携パターン比較

## 方法論 - データ連携

| パターン | 即時性 | 耐障害性 | 一貫性 |
|----------|--------|----------|--------|
| API連携 | ◎ | △ | ◎ |
| イベント連携 | ○ | ○ | ○ |
| データ基盤経由 | △ | ◎ | ◎ |

<!--
3つのパターンを比較します。
API連携は即時性が高いですが、依存先の障害の影響を受けます。
イベント連携はバランスが取れていますが、結果整合性になります。
データ基盤経由は即時性は劣りますが、耐障害性と一貫性に優れます。
-->

---

# 選択基準

## 方法論 - データ連携

- **即時性が必要** → API連携 or イベント連携
- **耐障害性・一貫性重視** → データ基盤経由
- **基盤障害を波及させない** → データ基盤経由をデフォルトに

<!--
選択基準です。
即時性が絶対に必要な場合はAPI連携かイベント連携を選びます。
耐障害性や一貫性を重視する場合はデータ基盤経由を選びます。
私たちは基盤障害の波及を防ぐため、データ基盤経由をデフォルトにしています。
-->

---

# Delta Lake + タイムトラベル

## 方法論 - データ連携

- Parquet形式でS3に保存（99.999999999%の耐久性）
- ACIDトランザクションをサポート
- タイムトラベル機能で過去の状態にアクセス可能

<!--
データ基盤にはDelta Lakeを採用しています。
S3に保存することで高い耐久性を確保し、ACIDトランザクションもサポートしています。
タイムトラベル機能により、過去の任意の時点のデータにアクセスできます。
-->

---

# タイムトラベルの活用

## 方法論 - データ連携

```python
# 現在のデータを取得
df = spark.read.format("delta").load("s3://bucket/users")

# 3ヶ月前の状態を取得
df_past = spark.read.format("delta") \
    .option("timestampAsOf", "2025-10-01") \
    .load("s3://bucket/users")
```

<!--
こちらがタイムトラベルの使用例です。
通常のロードでは最新データを取得しますが、timestampAsOfオプションを指定することで過去の状態を取得できます。
これにより「3ヶ月前のデータがどうだったか」という問い合わせに即座に回答できます。
-->

---

# サービスベースアーキテクチャ

## 方法論 - アーキテクチャ

- マイクロサービスでもモノリスでもない選択肢
- 単一DBを共有しつつ、サービスを論理的に分離
- トランザクションによる整合性保証

<!--
次に、アーキテクチャについてお話しします。
私たちはマイクロサービスでもモノリスでもない、サービスベースアーキテクチャを選択しました。
単一のDBを共有しながらサービスを論理的に分離することで、整合性を保ちつつ適度な分離を実現しています。
-->

---

# なぜマイクロサービスではないのか

## 方法論 - アーキテクチャ

1. モノリス → スケーラビリティの問題
2. マイクロサービス → 分散トランザクション、整合性の問題
3. **サービスベースアーキテクチャ** → 適度な分離と整合性のバランス

<!--
アーキテクチャの選択肢を比較します。
モノリスはスケーラビリティに課題があります。
マイクロサービスは分散トランザクションや結果整合性の複雑さがあります。
サービスベースアーキテクチャは、その中間で適度な分離と整合性のバランスが取れています。
-->

---

# サービスベースアーキテクチャ

## 方法論 - アーキテクチャ

- 単一のPostgreSQLを共有
- トランザクションで整合性を保証
- サービス間通信を原則禁止

<!--
私たちの選択の理由です。
単一のPostgreSQLを共有することで、トランザクションによる強い整合性を保証できます。
また、サービス間通信を原則禁止することで、障害の連鎖を防いでいます。
-->

---

# サービス間の結合度管理

## 方法論 - アーキテクチャ

- 各サービスは自分のテーブルにのみ書き込み権限
- 他のテーブルは読み取り専用ユーザーで参照
- 外部キー制約でデータ整合性を保証

<!--
サービス間の結合度を管理するためのルールです。
各サービスは自分のスキーマにのみ書き込み権限を持ちます。
他のスキーマは読み取り専用でアクセスし、外部キー制約で整合性を保証します。
-->

---

# DBユーザー分離の実装

## 方法論 - アーキテクチャ

```sql
-- サービスAのユーザー（自分のテーブルのみ書き込み可能）
CREATE USER service_a_user WITH PASSWORD '...';
GRANT SELECT, INSERT, UPDATE, DELETE ON service_a.* TO service_a_user;
GRANT SELECT ON service_b.* TO service_a_user;  -- 他は読み取りのみ

-- 外部キー制約で整合性を保証
ALTER TABLE service_a.orders
  ADD CONSTRAINT fk_user
  FOREIGN KEY (user_id) REFERENCES service_b.users(id);
```

<!--
こちらが実装例です。
サービスAのユーザーは、service_aスキーマには全権限、service_bスキーマには読み取りのみの権限を持ちます。
外部キー制約により、参照整合性がDBレベルで保証されます。
-->

---

# RLS

## 方法論 - RLS

- マルチテナントSaaSにおけるデータ分離
- アプリケーションのバグがあっても漏洩しない
- DBレベルでの強制的な保護

<!--
最後に、RLS（行レベルセキュリティ）についてお話しします。
マルチテナントSaaSでは、テナント間のデータ分離が極めて重要です。
RLSを使うことで、アプリケーションにバグがあっても他テナントのデータが漏洩しません。
-->

---

# RLSの選択理由

## 方法論 - RLS

**課題**: 顧客Aのデータを顧客Bが絶対に参照できないようにする

1. アプリケーションレベルでのフィルタリング → 実装ミスのリスク
2. スキーマ分離 → 管理コストが膨大
3. **行レベルセキュリティ（RLS）** → DBレベルで強制保護

<!--
なぜRLSを選んだかを説明します。
課題は「顧客Aのデータを顧客Bが絶対に参照できないようにする」ことです。
アプリレベルのフィルタリングは実装ミスのリスクがあり、スキーマ分離は管理コストが高すぎます。
RLSはDBレベルで強制的に保護できるため、最も安全です。
-->

---

# RLSのメリット

## 方法論 - RLS

- SQLインジェクションやバグがあっても他テナントのデータは漏洩しない
- ポリシーはテーブル定義と一緒に管理できる
- 既存のクエリを変更する必要がない

<!--
RLSのメリットです。
SQLインジェクションやアプリケーションのバグがあっても、他テナントのデータには絶対にアクセスできません。
ポリシーはDDLの一部として管理でき、既存のクエリを変更する必要もありません。
-->

---

# RLSの実装指針

## 方法論 - RLS

- 接続ごとにテナントコンテキストを設定
- ポリシーでテナントIDをチェック
- すべてのテーブルでRLSを有効化

<!--
RLSの実装指針です。
データベース接続ごとにテナントコンテキストを設定します。
ポリシーでそのテナントIDをチェックし、すべてのテーブルでRLSを有効化します。
-->

---

# RLSの実装パターン

## 方法論 - RLS

```sql
-- テナントコンテキストの設定
SET app.current_tenant_id = 'tenant_123';

-- RLSポリシーの定義
CREATE POLICY tenant_isolation_policy ON users
  USING (tenant_id = current_setting('app.current_tenant_id')::uuid);

ALTER TABLE users ENABLE ROW LEVEL SECURITY;
```

<!--
こちらがPostgreSQLでの実装例です。
まずSETコマンドでテナントIDをセッション変数に設定します。
ポリシーはcurrent_settingでその値を参照し、tenant_idが一致する行のみアクセスを許可します。
-->

---

# アプリケーション側の実装

## 方法論 - RLS

```typescript
// リクエストごとにテナントIDを設定
const tenantMiddleware = async (req, res, next) => {
  const tenantId = extractTenantId(req);

  // DB接続時にテナントコンテキストを設定
  await db.query(`SET app.current_tenant_id = $1`, [tenantId]);

  next();
};

// これ以降のクエリは自動的にテナントでフィルタリングされる
const users = await db.query('SELECT * FROM users');
```

<!--
アプリケーション側の実装です。
ミドルウェアでリクエストからテナントIDを抽出し、DBセッションに設定します。
これ以降のクエリは自動的にテナントでフィルタリングされ、WHERE句を書く必要がありません。
-->

---

# 結果と教訓

## 結果と教訓

- 導入して終わりではない
- 運用・監視・改善を継続することが本質
- 失敗から学んだことも共有

<!--
ここからは結果と教訓についてお話しします。
これらの方法論は導入して終わりではありません。
運用・監視・改善を継続することが本質であり、私たちの失敗から学んだことも共有します。
-->

---

# 成果

## 結果と教訓

| 項目 | Before | After |
|------|--------|-------|
| 障害発生時の原因特定時間 | 数時間〜 | 大幅に短縮 |
| 過去データの追跡 | 不可能 | 任意の時点で可能 |
| テナント分離の信頼性 | アプリ依存 | DB保証 |

<!--
導入による成果です。
障害発生時の原因特定時間が大幅に短縮されました。
過去データの追跡が任意の時点で可能になり、監査対応も容易になりました。
テナント分離もアプリ依存からDB保証に変わり、信頼性が向上しました。
-->

---

# 失敗から学んだこと

## 結果と教訓

- RLSのマイグレーションは慎重に（PERMISSIVEモードから開始）
- 共通ライブラリにビジネスロジックを入れすぎない
- 理想的には最初からイベントを記録すべき

<!--
失敗から学んだことも共有します。
RLSのマイグレーションは、まずPERMISSIVEモードで始め、影響を確認しながら進めるべきでした。
共通ライブラリにビジネスロジックを入れすぎると、変更が困難になります。
また、理想的には設計初期からイベント記録を組み込むべきでした。後からの導入は工数がかかります。
-->

---

# 「責任を果たす」とは

## 結果と教訓

1. **設計の意図を理解する**
2. **運用し続ける**
3. **監視する**
4. **改善し続ける**

<!--
「責任を果たす」とは何かをまとめます。
まず設計の意図を理解すること。次に運用し続けること。
そして監視により状態を把握すること。最後に改善し続けること。
この4つのサイクルを回し続けることが、責任を果たすということです。
-->

---

# 責任を果たすサイクル

## 結果と教訓

- **設計**: 原則に基づいて技術を選択
- **運用**: 本番環境で動かし続ける
- **監視**: メトリクス・ログ・アラートで状態を把握
- **改善**: 問題を発見したら修正し、設計にフィードバック

このサイクルを開発チームが自走できる状態を目指す

<!--
責任を果たすサイクルです。
設計で原則に基づいて技術を選び、運用で本番環境で動かし続けます。
監視でメトリクスやログ、アラートで状態を把握し、改善で問題を修正し設計にフィードバックします。
このサイクルを開発チームが自走できる状態を目指します。
-->

---

# まとめ

## まとめ

- 開発チームでも信頼性向上は実現できる
- 重要なのは技術選定だけでなく、運用し続けること
- 今日紹介した4つの方法論は段階的に導入可能

<!--
まとめです。
開発チームでも信頼性向上は実現できます。SRE専任チームがいなくても諦める必要はありません。
重要なのは技術選定だけでなく、運用し続けることです。
今日紹介した4つの方法論は、段階的に導入可能です。
-->

---

# 開発チームができること

## まとめ

1. **ドメインイベント**: トレーサビリティの確保
2. **データ連携パターン**: ユースケースに応じた選択
3. **サービスベースアーキテクチャ**: 強い整合性
4. **RLS**: DBレベルでのセキュリティ

<!--
開発チームができることの振り返りです。
ドメインイベントでトレーサビリティを確保し、データ連携パターンはユースケースに応じて選択します。
サービスベースアーキテクチャで強い整合性を実現し、RLSでDBレベルのセキュリティを確保します。
-->

---

# Enablingの観点から

## まとめ

- 設計を選ぶだけでなく、責任を果たす
- 運用・監視・改善を継続する
- 「誰かの仕事」ではなく「自分たちの責任」

<!--
Enablingの観点からまとめます。
開発チームが自分事として信頼性を担う状態を目指します。
設計を選ぶだけでなく責任を果たし、運用・監視・改善を継続することが重要です。
信頼性は「誰かの仕事」ではなく「自分たちの責任」です。
-->

---

# 本日のキーメッセージ（再掲）

## まとめ

- 設計パターンは「導入して終わり」ではない
- チームで意図を共有し、継続的に改善する
- それが開発チームによる信頼性向上の本質

<!--
最後に、本日のキーメッセージを再掲します。
設計パターンは導入して終わりではありません。
チームで意図を共有し、継続的に改善する。それが開発チームによる信頼性向上の本質です。
ご清聴ありがとうございました。
-->

---

# ご清聴ありがとうございました

## Q&A

質問があればぜひ！

<!--
以上で発表を終わります。
ご質問があればお気軽にどうぞ。
-->
